# Spring   
  
  #### [ 2022-11-18 ]  
  
  ## 목차  
  * #### [[ Servlet이란 ]](#servlet이란)  
  * #### [[ Servlet 특징 ]](#servlet-특징)  
  * #### [[ Servlet Container(서블릿 컨테이너) ]](#servelt-container서블릿-컨테이너)  
  * #### [[ Servlet Container 역할 ]](#servelt-container-역할)  
  * #### [[ Servlet 생명주기 ]](#servlet-생명주기)  
  * #### [[ JSP ]](#jsp)  
  * #### [[ Servlet Container와 멀티쓰레드 ]](#servlet-container와-멀티쓰레드)  
  * #### [[ DispatcherServlet ]](#dispatcherServlet)  
  * #### [[ DispatcherServlet의 구조 ]](#dispatcherServlet의-구조)  
      
---------------------------------------------------------------------------------------------------------------------------------------------------
  
출처 : https://mangkyu.tistory.com/14, https://studyandwrite.tistory.com/459, https://velog.io/@seculoper235/2.-DispatcherServlet-%EC%9D%B4%EB%9E%80  
    
* ### Servlet이란  

  Servlet이란 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술이다.  
  
  클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램이다.   
    
  예를 들어, 어떠한 사용자가 로그인을 하려고 할 때. 사용자는 아이디와 비밀번호를 입력하고, 로그인 버튼을 누른다.     
    
  그때 서버는 클라이언트의 아이디와 비밀번호를 확인하고, 다음 페이지를 띄워주어야 하는데, 이러한 역할을 수행하는   
  것이 바로 서블릿(Servlet)입니다. 그래서 서블릿은 자바로 구현 된 ```CGI```라고 흔히 말한다.  

  자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램이다.  
  쉽게 이야기하면, 클라이언트가 서버에 요청을 보낼 때와 응답을 받을 때 필요한 HTTP 작업을 도와주는 녀석이 서블릿이다. 

  그리고 '동적으로'라고 말할 수 있는 것은 스프링에서 Servlet을 사용할 때 HttpServlet을 상속받아 사용하는데,   
  이 때 HTTP request와 response 안에 Header, Body 등의 내용을 입력할 수 있기 때문이다.  
  
  * #### GCI란?  

    ```
    CGI는 특별한 라이브러리나 도구를 의미하는 것이 아니고, 별도로 제작된 웹서버와 프로그램간의 교환방식이다.     
    CGI방식은 어떠한 프로그래밍언어로도 구현이가능하며, 별도로 만들어 놓은 프로그램에 HTML의 Get or Post 방법으로 클라이언트의 데이터를 환경변수로 전달하고,   
    프로그램의 표준 출력 결과를 클라이언트에게 전송하는 것이다.  
    즉, 자바 어플리케이션 코딩을 하듯 웹 브라우저용 출력 화면을 만드는 방법이다.  
    ```
    
  ```
  POST /save HTTP/1.1
  Host: localhost:8080
  Content-Type: application/x-www-form-urlencoded

  username = "jeongil"&password="1234"
  ```
  
  이러한 http request를 받게 된다 가정하면 서버는 웹 브라우저가 생성한 요청 메시지를 받아서 아래 작업들을 처리해야 한다.  
    
  - 서버 TCP/IP 연결 대기, 소켓 연결  
  - HTTP 요청 메시지를 파싱해서 읽기  
  - POST 방식, /save URL 인지  
  - Content-Type 확인  
  - HTTP 메시지 바디 내용 파싱  
  - 저장 프로세스 실행  
  - 비즈니스 로직 실행 → 데이터베이스에 저장 요청  
  - HTTP 응답 메시지 생성   
  - TCP/IP에 응답 전달, 소켓 종료  

  그런데 우리가 실제로 개발을 하는 것을 생각해보면 ```비즈니스 로직 실행 → 데이터베이스에 저장 요청```을 작성하는 것 외의 서버 수행해야 하는 여러가지 일들을 일일이 처리한 적이 없었다는 것을 알 수 있다.
    
  바로 이 부분을 서블릿이 처리해주기 때문이다.    
      
  따라서, 서블릿을 지원하는 WAS를 사용함으로써 개발자는 의미있는 비즈니스 로직에 중심을 두게 되고    
  서블릿은 HttpServletRequest, HttpServletResponse를 통해 HTTP 통신에서 필요한 여러가지 작업을 하게 된다.    
  
* ### Servlet 특징  

  클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트
  
  - html을 사용하여 요청에 응답한다.  
  
  - Java Thread를 이용하여 동작한다.  
  
  - MVC 패턴에서 Controller로 이용된다.  
  
  - HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.  
  
  - UDP보다 처리 속도가 느리다.  
  
  - HTML 변경 시 Servlet을 재컴파일해야 하는 단점이 있다.  
  
  
  일반적으로 웹서버는 정적인 페이지만을 제공한다. 그렇기 때문에 동적인 페이지를 제공하기 위해서 웹서버는 
  다른 곳에 도움을 요청하여 동적인 페이지를 작성해야 한다. 동적인 페이지로는 임의의 이미지만을 보여주는 페이지와 같이
  사용자가 요청한 시점에 페이지를 생성해서 전달해 주는 것을 의미한다.   
  여기서 웹서버가 동적인 페이지를 제공할 수 있도록 도와주는 어플리케이션이 서블릿이며, 동적인 페이지를 생성하는 어플리케이션이 CGI이다.  
    
  * #### HTTP 프로토콜을 이용한 서버와 클라이언트의 통신 과정은?  

    ```
    클라이언트는 정보를 얻기 위해 서버로 HTTP 요청을 전송하고, 서버는 이를 해석하여 정적 자원에 대한 요청일 경우 자원을 반환해주고,   
    그렇지 않은 경우 CGI 프로그램을 실행시켜 해당 결과를 리턴해준다.   
    이때 서버는 CGI 프로그램에게 요청을 전달해주고, 결과를 전달받기 위한 파이프라인을 연결한다.   
    그래서 CGI 프로그램은 입력에 대한 서비스를 수행하고,   
    결과를 클라이언트에게 전달하기 위해 결과 페이지에 해당하는 MIME 타입의 컨텐츠데이터를 웹 서버와 연결된 파이프라인에 출력하여 서버에 전달한다.   
    서버는 파이프라인을 통해 CGI 프로그램에서 출력한 결과 페이지의 데이터를 읽어, HTTP 응답헤더를 생성하여 데이터를 함께 반환해준다.  
    ```
    
* ### Servlet Container(서블릿 컨테이너)  

  서블릿 컨테이너는 서블릿을 이해했다면 상당히 쉽게 이해할 수 있다.  
    
  서블릿 컨테이너란 서블릿을 관리해주는 컨테이너이다.  
    
  ```
  우리가 서버에 서블릿을 만들었다고 해서 스스로 작동하는 것이 아니고 서블릿을 관리해주는 것이 필요한데,   
  그러한 역할을 하는 것이 바로 서블릿 컨테이너 입니다. 예를 들어, 서블릿이 어떠한 역할을 수행하는 정의서라고 보면,   
  서블릿 컨테이너는 그 정의서를 보고 수행한다고 볼 수 있다.   
  서블릿 컨테이너는 클라이언트의 요청(Request)을 받아주고 응답(Response)할 수 있게, 웹서버와 소켓으로 통신하며 대표적인 예로 톰캣(Tomcat)이 있다.   
  톰캣은 실제로 웹 서버와 통신하여 JSP(자바 서버 페이지)와 Servlet이 작동하는 환경을 제공해준다.  
  ```
    
* ### Servlet Container 역할  

  - 웹서버와의 통신 지원  

    서블릿 컨테이너는 서블릿과 웹서버가 손쉽게 통신할 수 있게 해줍니다. 일반적으로 우리는 소켓을 만들고 listen,   
    accept 등을 해야하지만 서블릿 컨테이너는 이러한 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해준다.  
    그래서 개발자가 서블릿에 구현해야 할 비지니스 로직에 대해서만 초점을 두게끔 도와준다.  
      
  - 서블릿 생명주기(Life Cycle) 관리   

    서블릿 컨테이너는 서블릿의 탄생과 죽음을 관리합니다. 서블릿 클래스를 로딩하여 인스턴스화하고,   
    초기화 메소드를 호출하고, 요청이 들어오면 적절한 서블릿 메소드를 호출한다.   
    또한 서블릿이 생명을 다 한 순간에는 적절하게 Garbage Collection(가비지 컬렉션)을 진행하여 편의를 제공한다.  
      
  - 멀티쓰레드 지원 및 관리  

    서블릿 컨테이너는 요청이 올 때 마다 새로운 자바 쓰레드를 하나 생성하는데, HTTP 서비스 메소드를  
    실행하고 나면, 쓰레드는 자동으로 죽게된다. 원래는 쓰레드를 관리해야 하지만 서버가 다중 쓰레드를  
    생성 및 운영해주니 쓰레드의 안정성에 대해서 걱정하지 않아도 된다.  
      
  - 선언적인 보안 관리   

    서블릿 컨테이너를 사용하면 개발자는 보안에 관련된 내용을 서블릿 또는 자바 클래스에 구현해 놓지 않아도 된다.   
    일반적으로 보안관리는 XML 배포 서술자에 다가 기록하므로, 보안에 대해 수정할 일이 생겨도 자바 소스 코드를   
    수정하여 다시 컴파일 하지 않아도 보안관리가 가능하다.  
      
* ### Servlet 생명주기  

  - 클라이언트의 요청이 들어오면 컨테이너는 해당 서블릿이 메모리에 있는지 확인하고, 없을 경우 ```init()```메소드를 호출하여 적재한다.   
    ```init()```메소드는 처음 한번만 실행되기 때문에, 서블릿의 쓰레드에서 공통적으로 사용해야하는 것이 있다면 오버라이딩하여 구현하면 된다.   
    실행 중 서블릿이 변경될 경우, 기존 서블릿을 파괴하고 ```init()```을 통해 새로운 내용을 다시 메모리에 적재한다.  
    
  - ```init()```이 호출된 후 클라이언트의 요청에 따라서 ```service()```메소드를 통해 요청에 대한 응답이 ```doGet()```가 ```doPost()```로 분기된다.   
    이때 서블릿 컨테이너가 클라이언트의 요청이 오면 가장 먼저 처리하는 과정으로 생성된 ```HttpServletRequest```, ```HttpServletResponse```에 의해 ```request```와 ```response```객체가 제공된다.
    
  - 컨테이너가 서블릿에 종료 요청을 하면 ```destroy()```메소드가 호출되는데 마찬가지로 한번만 실행되며, 종료시에 처리해야하는 작업들은 destroy()메소드를 오버라이딩하여 구현하면 된다.  

* ### JSP  

  지금까지 이해를 잘 했다면 JSP에 대해서도 어렵지 않게 받아들일 수 있을 것이다.  
  
  JSP란 Java 코드가 들어가 있는 HTML 코드이다.  
    
  서블릿은 자바 소스코드 속에 HTML코드가 들어가는 형태인데, JSP는 이와 반대로 HTML 소스코드 속에 자바 소스코드가 들어가는 구조를 갖는 웹어플리케이션 프로그래밍 기술이다.  
    
  서블릿 규칙은 꽤나 복집하기 때문에 JSP가 나오게 되었는데 JSP는 WAS(Web Application Server)에 의하여 서블릿 클래스로 변환하여 사용되어 진다.  
    
  
* ### Servlet Container와 멀티쓰레드  

  한 명의 클라이언트가 서버에 HTTP 요청을 하는 상황을 생각해보자.  
    
  ![image url](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbG2MGJ%2FbtrjP1exbTE%2FhVJ2kgyIPsnf9fVcvnkUl0%2Fimg.jpg)  
    
  이 때, 클라이언트가 보낸 요청에 대해 서버에서 연결을 받고, WAS(서블릿 컨테이너)에서는 Servlet 객체를 호출하여 HTTP 요청을 처리한다.  
  그런데 여기서 서블릿 객체를 호출하는 주체는 누구일까?  
    
  서블릿 컨테이너에서 서블릿 객체를 호출하는 역할을 하는 녀석이 바로 쓰레드입니다.

  쓰레드는 애플리케이션 코드를 하나하나 순차적으로 실행하는 작업을 한다.    

  자바 Main 메서드를 실행하면 main이라는 쓰레드가 실행되고, 동시 처리가 필요하면 쓰레드를 추가로 생성해서 처리를 하게 된다.    

  따라서, 동시에 여러 클라이언트가 서버에 요청을 보내게 되면 여러 개의 쓰레드를 생성하고 각 쓰레드는 서블릿 객체를 호출하여 작업을 처리하는 것이다.    

  하지만 모든 요청마다 쓰레드를 생성하게 되면 동시 요청은 처리할 수 있지만, 쓰레드의 생성 비용이 많이 드는 단점이 존재하고 쓰레드의 컨텍스트 스위칭(Contetxt Switching) 비용이 발생할 수 있다(물론 멀티 프로세스보다는 덜 하겠지만).  

  그리고 너무나 많은 요청이 들어오면 쓰레드를 무한정 생성해야 하기 때문에 CPU의 한계를 넘어서서 서버가 다운될 수 있는 상황까지 초래하게 된다.  

  그래서 WAS는 아래처럼 쓰레드 풀(Thread Pool)이라는 개념을 사용합니다.  

  쓰레드 풀은 처음에 일정한 수의 쓰레드를 미리 생성해놓고 클라이언트의 요청이 오면 쓰레드풀 안에 있는 쓰레드를 할당하고 쓰레드가 클라이언트의 요청을 처리하면 해당 쓰레드를 다시 반납받는다.  
    
  ![image url](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F74gi3%2FbtrjNbCrV1b%2FyBXxeC45lAokiS6ykFtivk%2Fimg.png)  
    
  톰캣은 최대 200개의 쓰레드를 쓰레드 풀에 생성하는데,   
  이런식으로 쓰레드를 미리 생성해놓음으로써 쓰레드를 생성하고 종료하는 비용이 절약되고, 응답 시간이 빨라질 수 있는 장점을 얻을 수 있다.  

  한편, 쓰레드가 모두 사용 중인 상황에서는 기다리는 요청에 대해 특정 숫자만큼만 대기하도록 설정할 수 있도록 만들수도 있다.  

  결국, WAS(서블릿 컨테이너)의 핵심 기능은 멀티 쓰레드 지원을 통한 동시 요청 처리를 해준다는 데 있다.  

  개발자가 멀티 쓰레드 관련 코드를 일일이 작성하지 않고 설정을 통해 멀티 쓰레드를 사용할 수 있기 때문에,   
  마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 비즈니스 로직에만 초점을 맞춰 개발할 수 있는 것이다.  
    
* ### DispatcherServlet  
  
  해당 클래스는 Servlet의 중심이자, Spring MVC의 중심이다.  
    
  디스패처 서블릿의 dispatch는 "보내다"라는 뜻을 가지고 있다.   
  그리고 이러한 단어를 포함하는 디스패처 서블릿은 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 
  ```프론트 컨트롤러(Front Controller)```라고 정의할 수 있다.  
    
  동작 원리나 특징 등을 살펴보기 전에, 왜 DispatcherServlet이 그렇게 대단한 건지 먼저 살펴보려 한다. 그러기 위해 일단 Spring이 없는 환경으로 돌아가보자.  
    
  * #### 지저분해지는 프로젝트  

    Spring이 없는 JAVA 런타임에서는 컨트롤러가 존재하지 않는다.  
    따라서 우리는 서블릿 객체를 생성하고, 그것을 web.xml에다 일일히 다 등록해줘야 했다.  
      
    ```xml
    <!-- 서블릿1 등록 -->
    <servlet>
        <servlet-name>서블릿1</servlet-name>
        ...
    </servlet>
    <servlet-mapping>
        <servlet-name>서블릿1</servlet-name>
        ...
    </servlet-mapping>

    <!-- 서블릿2 등록 -->
    <servlet>
        <servlet-name>서블릿2</servlet-name>
        ...
    </servlet>
    <servlet-mapping>
        <servlet-name>서블릿2</servlet-name>
        ...
    </servlet-mapping>

    <!-- 서블릿3 등록 -->
    <servlet>
        <servlet-name>서블릿3</servlet-name>
        ...
    </servlet>
    <servlet-mapping>
        <servlet-name>서블릿3</servlet-name>
        ...
    </servlet-mapping>
    ```
      
    하지만 웹사이트를 이용해봤다면 알겠지만, 우리가 접속하는 페이지(경로)는 한두개가 아니다.  
    메뉴 페이지, 로그인 페이지, 관리자 페이지 등 아무리 적게 잡아도 최소 10개이다.  
  
    게다가 컨트롤러와는 달리 서블릿 객체 하나는 하나의 경로만 담당한다.  
    이렇게되면 10개보다 더 늘어날 것이고,  
    프로젝트 문서는 온통 서블릿 객체로 넘쳐날 것이다.  
      
  * #### 높은 의존성  
    
    Servlet 객체는 HttpServlet를 확장한 객체이다.  
    이렇게 되면 HttpServlet 기능을 필수로 Override 해야 하고, 더이상 일반 객체로 사용할 수 없다.  
    즉, 클래스끼리 값을 주고받기가 까다로워진다는 것이다.  
      
  * #### 중복되는 작업  

    모든 서블릿이 공통으로 처리하는 작업이나, 가장 우선시 되야하는 작업이 분명 있을 것이다.  
    이런 것을 서블릿 객체로 처리하기란 불가능하고, 매우 까다로울 것이다.  
      
  DispatcherServlet은 이러한 단점들을 모두 해소해주고, 간편하게 사용할 수 있다.   
    
* ### DispatcherServlet의 구조    

  * #### Controller의 등장  
    
    서블릿을 더이상 HttpServlet을 확장하지 않고, POJO를 사용한다.  
    ```@Controller``` 어노테이션을 붙여서 간편히 사용할 수 있으며, 의존성이 낮아져서 다른 객체들과 연계가 자유롭다.  
    
  * #### Dispatcher-Servlet(디스패처 서블릿)의 동작 방식  

    디스패처 서블릿은 적합한 컨트롤러와 메소드를 찾아 요청을 위임해야 한다. Dispatcher Servlet의 처리 과정을 살펴보면 다음과 같다.  

    ![image url](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbImFbg%2FbtrGzZMTuu2%2FCkY4MiKvl5ivUJPoc5I3zk%2Fimg.png)  
      
    - 클라이언트의 요청을 디스패처 서블릿이 받음  
    - 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음  
    - 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함  
    - 핸들러 어댑터가 컨트롤러로 요청을 위임함  
    - 비지니스 로직을 처리함  
    - 컨트롤러가 반환값을 반환함  
    - HandlerAdapter가 반환값을 처리함  
    - 서버의 응답을 클라이언트로 반환함  
  
  DispatcherServlet이 모든 요청을 받고 세부 경로는 각 Controller에게 뿌려주는 프론트 컨트롤러의 역할을 함으로써, web.xml에 서블릿을 일일히 등록할 필요가 없어졌다.  
  Controller의 매핑은 DispatcherServlet이 담당하기 때문이다.  
    
  서블릿을 공부하다보면 그 당시 개발자들이 서블릿'만'으로 개발을 하다 sprin을 접하고 얼마나 편해졌음을 느꼈을 지 감히 예측하기도 어렵다고 느껴진다.  
    
  
